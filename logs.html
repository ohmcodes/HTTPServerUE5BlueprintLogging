<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>HTTP Log Server — Live Logs</title>
    <link rel="stylesheet" href="/static/style.css">
    <style>html,body{height:100%;margin:0}</style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <div class="brand">
                <div class="logo">L</div>
                <div>
                    <h1>HTTP Log Server</h1>
                    <div class="meta">Live streaming logs • Simple UX for quick troubleshooting</div>
                </div>
            </div>
            <div style="display:flex;align-items:center;gap:18px">
                <nav>
                    <a href="/">Home</a>
                    <a href="/logs/list">Archives</a>
                    <a href="/docs">Docs</a>
                </nav>
                <div class="controls">
                    <button class="btn" onclick="requestClearOnly()">Clear (no archive)</button>
                    <button class="btn" onclick="requestArchive()">Save / Archive</button>
                </div>
            </div>
        </header>

        <main class="container">
            <section class="panel" style="display:flex;flex-direction:column">
                <div class="meta">Live stream (latest at bottom)</div>
                <div id="logsContainer" class="logs" aria-live="polite">
                    <ul id="logList" style="list-style:none;padding:0;margin:0"></ul>
                </div>
            </section>
            <aside style="width:280px">
                <div class="panel">
                    <h3 style="margin-top:0">Actions</h3>
                    <p style="margin:8px 0;color:var(--muted)">Quick controls for managing logs</p>
                    <div style="display:flex;flex-direction:column;gap:8px">
                        <button class="btn primary" onclick="requestArchive()">Save & Clear</button>
                        <button class="btn" onclick="requestClearOnly()">Clear (no archive)</button>
                        <a class="btn" href="/logs/archives">View archives (JSON)</a>
                        <a class="btn" href="/logs/list">Archived logs (page)</a>
                    </div>
                </div>
            </aside>
        </main>

        <footer>Archive files saved to <code>/archives</code> • Logs persisted in <code>/logs.json</code></footer>
    </div>

    <script>
        (function () {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            const url = protocol + '//' + host;
            let socket = null;
            let reconnectDelay = 1000;
            const maxDelay = 30000;

            const logList = document.getElementById('logList');
            const container = document.getElementById('logsContainer');

            function appendLog(text, opts = {}) {
                const li = document.createElement('li');
                li.className = 'log-item';
                li.textContent = text;
                logList.appendChild(li);
                if (opts.smooth && container) container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
            }

            function appendLogsBatch(items) {
                const frag = document.createDocumentFragment();
                for (const item of items) {
                    const li = document.createElement('li');
                    li.className = 'log-item';
                    li.textContent = item;
                    frag.appendChild(li);
                }
                logList.appendChild(frag);
                if (container) container.scrollTop = container.scrollHeight;
            }

            let lastInitCount = 0;
            let lastInitLastItem = null;

            function handleEnvelope(msg) {
                if (!msg || !msg.type) return;
                if (msg.type === 'init' && Array.isArray(msg.data)) {
                    const MAX_INIT = 500;
                    const items = msg.data.length > MAX_INIT ? msg.data.slice(-MAX_INIT) : msg.data;
                    const lastItem = items.length ? items[items.length - 1] : null;
                    if (lastInitCount === items.length && lastInitLastItem === lastItem) return;
                    logList.innerHTML = '';
                    appendLogsBatch(items);
                    lastInitCount = items.length;
                    lastInitLastItem = lastItem;
                } else if (msg.type === 'new' && Array.isArray(msg.data)) {
                    for (const item of msg.data) appendLog(item, { smooth: true });
                } else if (msg.type === 'archive' && msg.data) {
                    const name = msg.data.archived || '(no archive)';
                    alert('Logs archived: ' + name);
                    if (msg.data.cleared) { logList.innerHTML = ''; if (container) container.scrollTop = 0; }
                } else if (msg.type === 'cleared' && msg.data) {
                    alert('Logs cleared (no archive)');
                    logList.innerHTML = '';
                    if (container) container.scrollTop = 0;
                }
            }

            function connect() {
                socket = new WebSocket(url);
                socket.addEventListener('open', () => { console.log('WS open'); reconnectDelay = 1000; });
                socket.addEventListener('message', (ev) => { try { handleEnvelope(JSON.parse(ev.data)); } catch (e) { console.error(e); } });
                socket.addEventListener('close', (ev) => { console.warn('WS close', ev.code); scheduleReconnect(); });
                socket.addEventListener('error', (e) => { console.error('WS error', e); socket.close(); });
            }

            function scheduleReconnect() { const jitter = Math.round(Math.random()*400); setTimeout(()=>{ reconnectDelay = Math.min(maxDelay, Math.max(1000, Math.round(reconnectDelay*2))); connect(); }, reconnectDelay + jitter); }
            connect();

            window.requestArchive = async function () {
                if (!confirm('Archive current logs and clear them on the server?')) return;
                try {
                    const res = await fetch('/logs/clear', { method: 'POST' });
                    if (!res.ok) throw new Error('Server returned ' + res.status);
                    const body = await res.json();
                    alert('Archive saved: ' + (body.archived || '(none)'));
                } catch (err) { alert('Failed to archive logs: ' + err.message); }
            };

            window.requestClearOnly = async function () {
                if (!confirm('Clear current logs on the server WITHOUT saving an archive?')) return;
                try {
                    const res = await fetch('/logs/clear-only', { method: 'POST' });
                    if (!res.ok) throw new Error('Server returned ' + res.status);
                    alert('Cleared current logs (no archive saved)');
                } catch (err) { alert('Failed to clear logs: ' + err.message); }
            };
        })();
    </script>
</body>
</html>
